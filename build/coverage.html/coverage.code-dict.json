{"/home/travis/build/npmtest/node-npmtest-statsd/test.js":"/* istanbul instrument in package npmtest_statsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-statsd/lib.npmtest_statsd.js":"/* istanbul instrument in package npmtest_statsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_statsd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_statsd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-statsd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-statsd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_statsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_statsd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_statsd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_statsd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_statsd.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_statsd.__dirname +\n                    '/lib.npmtest_statsd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/backends/console.js":"/*jshint node:true, laxcomma:true */\n\nvar util = require('util');\n\nfunction ConsoleBackend(startupTime, config, emitter){\n  var self = this;\n  this.lastFlush = startupTime;\n  this.lastException = startupTime;\n  this.config = config.console || {};\n\n  // attach\n  emitter.on('flush', function(timestamp, metrics) { self.flush(timestamp, metrics); });\n  emitter.on('status', function(callback) { self.status(callback); });\n}\n\nConsoleBackend.prototype.flush = function(timestamp, metrics) {\n  console.log('Flushing stats at ', new Date(timestamp * 1000).toString());\n\n  var out = {\n    counters: metrics.counters,\n    timers: metrics.timers,\n    gauges: metrics.gauges,\n    timer_data: metrics.timer_data,\n    counter_rates: metrics.counter_rates,\n    sets: function (vals) {\n      var ret = {};\n      for (var val in vals) {\n        ret[val] = vals[val].values();\n      }\n      return ret;\n    }(metrics.sets),\n    pctThreshold: metrics.pctThreshold\n  };\n\n  if(this.config.prettyprint) {\n    console.log(util.inspect(out, {depth: 5, colors: true}));\n  } else {\n    console.log(out);\n  }\n\n};\n\nConsoleBackend.prototype.status = function(write) {\n  ['lastFlush', 'lastException'].forEach(function(key) {\n    write(null, 'console', key, this[key]);\n  }, this);\n};\n\nexports.init = function(startupTime, config, events) {\n  var instance = new ConsoleBackend(startupTime, config, events);\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/backends/graphite.js":"/*jshint node:true, laxcomma:true */\n\n/*\n * Flush stats to graphite (http://graphite.wikidot.com/).\n *\n * To enable this backend, include 'graphite' in the backends\n * configuration array:\n *\n *   backends: ['graphite']\n *\n * This backend supports the following config options:\n *\n *   graphiteHost: Hostname of graphite server.\n *   graphitePort: Port for the graphite text collector. Defaults to 2003.\n *   graphitePicklePort: Port for the graphite pickle collector. Defaults to 2004.\n *   graphiteProtocol: Either 'text' or 'pickle'. Defaults to 'text'.\n * \n * If graphiteHost is not specified, metrics are processed but discarded.\n */\n\nvar net = require('net');\n\n// this will be instantiated to the logger\nvar l;\n\nvar debug;\nvar flushInterval;\nvar graphiteHost;\nvar graphitePort;\nvar graphitePicklePort;\nvar graphiteProtocol;\nvar flush_counts;\n\n// prefix configuration\nvar globalPrefix;\nvar prefixCounter;\nvar prefixTimer;\nvar prefixGauge;\nvar prefixSet;\nvar globalSuffix;\nvar prefixStats;\nvar globalKeySanitize = true;\n\n// set up namespaces\nvar legacyNamespace  = true;\nvar globalNamespace  = [];\nvar counterNamespace = [];\nvar timerNamespace   = [];\nvar gaugesNamespace  = [];\nvar setsNamespace    = [];\n\nvar graphiteStats = {};\n\nvar post_stats = function graphite_post_stats(stats) {\n  var last_flush = graphiteStats.last_flush || 0;\n  var last_exception = graphiteStats.last_exception || 0;\n  var flush_time = graphiteStats.flush_time || 0;\n  var flush_length = graphiteStats.flush_length || 0;\n\n  if (graphiteHost) {\n    try {\n      var port = graphiteProtocol == 'pickle' ? graphitePicklePort : graphitePort;\n      var graphite = net.createConnection(port, graphiteHost);\n      graphite.addListener('error', function(connectionException){\n        if (debug) {\n          l.log(connectionException);\n        }\n      });\n      graphite.on('connect', function() {\n        var ts = Math.round(Date.now() / 1000);\n        var namespace = globalNamespace.concat(prefixStats).join(\".\");\n        stats.add(namespace + '.graphiteStats.last_exception' + globalSuffix, last_exception, ts);\n        stats.add(namespace + '.graphiteStats.last_flush'     + globalSuffix, last_flush    , ts);\n        stats.add(namespace + '.graphiteStats.flush_time'     + globalSuffix, flush_time    , ts);\n        stats.add(namespace + '.graphiteStats.flush_length'   + globalSuffix, flush_length  , ts);\n        var stats_payload = graphiteProtocol == 'pickle' ? stats.toPickle() : stats.toText();\n\n        var starttime = Date.now();\n        this.write(stats_payload);\n        this.end();\n\n        graphiteStats.flush_time = (Date.now() - starttime);\n        graphiteStats.flush_length = stats_payload.length;\n        graphiteStats.last_flush = Math.round(Date.now() / 1000);\n      });\n    } catch(e){\n      if (debug) {\n        l.log(e);\n      }\n      graphiteStats.last_exception = Math.round(Date.now() / 1000);\n    }\n  }\n};\n\n// Minimally necessary pickle opcodes.\nvar MARK = '(',\n    STOP = '.',\n    LONG = 'L',\n    STRING = 'S',\n    APPEND = 'a',\n    LIST = 'l',\n    TUPLE = 't';\n\n// A single measurement for sending to graphite.\nfunction Metric(key, value, ts) {\n  var m = this;\n  this.key = key;\n  this.value = value;\n  this.ts = ts;\n\n  // return a string representation of this metric appropriate \n  // for sending to the graphite collector. does not include\n  // a trailing newline.\n  this.toText = function() {\n    return m.key + \" \" + m.value + \" \" + m.ts;\n  };\n\n  this.toPickle = function() {\n    return MARK + STRING + '\\'' + m.key + '\\'\\n' + MARK + LONG + m.ts + 'L\\n' + STRING + '\\'' + m.value + '\\'\\n' + TUPLE + TUPLE + APPEND;\n  };\n}\n\n// A collection of measurements for sending to graphite.\nfunction Stats() {\n  var s = this;\n  this.metrics = [];\n  this.add = function(key, value, ts) {\n    s.metrics.push(new Metric(key, value, ts));\n  };\n\n  this.toText = function() {\n    return s.metrics.map(function(m) { return m.toText(); }).join('\\n') + '\\n';\n  };\n\n  this.toPickle = function() {\n    var body = MARK + LIST + s.metrics.map(function(m) { return m.toPickle(); }).join('') + STOP;\n\n    // The first four bytes of the graphite pickle format\n    // contain the length of the rest of the payload.\n    // We use Buffer because this is binary data.\n    var buf = new Buffer(4 + body.length);\n\n    buf.writeUInt32BE(body.length,0);\n    buf.write(body,4);\n\n    return buf;\n  };\n}\n\nvar flush_stats = function graphite_flush(ts, metrics) {\n  var starttime = Date.now();\n  var numStats = 0;\n  var key;\n  var timer_data_key;\n  var counters = metrics.counters;\n  var gauges = metrics.gauges;\n  var timers = metrics.timers;\n  var sets = metrics.sets;\n  var counter_rates = metrics.counter_rates;\n  var timer_data = metrics.timer_data;\n  var statsd_metrics = metrics.statsd_metrics;\n\n  // Sanitize key for graphite if not done globally\n  function sk(key) {\n    if (globalKeySanitize) {\n      return key;\n    } else {\n      return key.replace(/\\s+/g, '_')\n                .replace(/\\//g, '-')\n                .replace(/[^a-zA-Z_\\-0-9\\.]/g, '');\n    }\n  };\n\n  // Flatten all the different types of metrics into a single\n  // collection so we can allow serialization to either the graphite\n  // text and pickle formats.\n  var stats = new Stats();\n\n  for (key in counters) {\n    var value = counters[key];\n    var valuePerSecond = counter_rates[key]; // pre-calculated \"per second\" rate\n    var keyName = sk(key);\n    var namespace = counterNamespace.concat(keyName);\n\n    if (legacyNamespace === true) {\n      stats.add(namespace.join(\".\") + globalSuffix, valuePerSecond, ts);\n      if (flush_counts) {\n        stats.add('stats_counts.' + keyName + globalSuffix, value, ts);\n      }\n    } else {\n      stats.add(namespace.concat('rate').join(\".\")  + globalSuffix, valuePerSecond, ts);\n      if (flush_counts) {\n        stats.add(namespace.concat('count').join(\".\") + globalSuffix, value, ts);\n      }\n    }\n\n    numStats += 1;\n  }\n\n  for (key in timer_data) {\n    var namespace = timerNamespace.concat(sk(key));\n    var the_key = namespace.join(\".\");\n\n    for (timer_data_key in timer_data[key]) {\n      if (typeof(timer_data[key][timer_data_key]) === 'number') {\n        stats.add(the_key + '.' + timer_data_key + globalSuffix, timer_data[key][timer_data_key], ts);\n      } else {\n        for (var timer_data_sub_key in timer_data[key][timer_data_key]) {\n          if (debug) {\n            l.log(timer_data[key][timer_data_key][timer_data_sub_key].toString());\n          }\n          stats.add(the_key + '.' + timer_data_key + '.' + timer_data_sub_key + globalSuffix,\n                    timer_data[key][timer_data_key][timer_data_sub_key], ts);\n        }\n      }\n    }\n    numStats += 1;\n  }\n\n  for (key in gauges) {\n    var namespace = gaugesNamespace.concat(sk(key));\n    stats.add(namespace.join(\".\") + globalSuffix, gauges[key], ts);\n    numStats += 1;\n  }\n\n  for (key in sets) {\n    var namespace = setsNamespace.concat(sk(key));\n    stats.add(namespace.join(\".\") + '.count' + globalSuffix, sets[key].size(), ts);\n    numStats += 1;\n  }\n\n  if (legacyNamespace === true) {\n    stats.add(prefixStats + '.numStats' + globalSuffix, numStats, ts);\n    stats.add('stats.' + prefixStats + '.graphiteStats.calculationtime' + globalSuffix, (Date.now() - starttime), ts);\n    for (key in statsd_metrics) {\n      stats.add('stats.' + prefixStats + '.' + key + globalSuffix, statsd_metrics[key], ts);\n    }\n  } else {\n    var namespace = globalNamespace.concat(prefixStats);\n    stats.add(namespace.join(\".\") + '.numStats' + globalSuffix, numStats, ts);\n    stats.add(namespace.join(\".\") + '.graphiteStats.calculationtime' + globalSuffix, (Date.now() - starttime) , ts);\n    for (key in statsd_metrics) {\n      var the_key = namespace.concat(key);\n      stats.add(the_key.join(\".\") + globalSuffix,+ statsd_metrics[key], ts);\n    }\n  }\n  post_stats(stats);\n\n  if (debug) {\n   l.log(\"numStats: \" + numStats);\n  }\n};\n\nvar backend_status = function graphite_status(writeCb) {\n  for (var stat in graphiteStats) {\n    writeCb(null, 'graphite', stat, graphiteStats[stat]);\n  }\n};\n\nexports.init = function graphite_init(startup_time, config, events, logger) {\n  debug = config.debug;\n  l = logger;\n  graphiteHost = config.graphiteHost;\n  graphitePort = config.graphitePort || 2003;\n  graphitePicklePort = config.graphitePicklePort || 2004;\n  graphiteProtocol = config.graphiteProtocol || 'text';\n  config.graphite = config.graphite || {};\n  globalPrefix    = config.graphite.globalPrefix;\n  prefixCounter   = config.graphite.prefixCounter;\n  prefixTimer     = config.graphite.prefixTimer;\n  prefixGauge     = config.graphite.prefixGauge;\n  prefixSet       = config.graphite.prefixSet;\n  globalSuffix    = config.graphite.globalSuffix;\n  legacyNamespace = config.graphite.legacyNamespace;\n  prefixStats     = config.prefixStats;\n\n  // set defaults for prefixes & suffix\n  globalPrefix  = globalPrefix !== undefined ? globalPrefix : \"stats\";\n  prefixCounter = prefixCounter !== undefined ? prefixCounter : \"counters\";\n  prefixTimer   = prefixTimer !== undefined ? prefixTimer : \"timers\";\n  prefixGauge   = prefixGauge !== undefined ? prefixGauge : \"gauges\";\n  prefixSet     = prefixSet !== undefined ? prefixSet : \"sets\";\n  prefixStats   = prefixStats !== undefined ? prefixStats : \"statsd\";\n  legacyNamespace = legacyNamespace !== undefined ? legacyNamespace : true;\n\n  // In order to unconditionally add this string, it either needs to be an\n  // empty string if it was unset, OR prefixed by a . if it was set.\n  globalSuffix  = globalSuffix !== undefined ? '.' + globalSuffix : '';\n\n  if (legacyNamespace === false) {\n    if (globalPrefix !== \"\") {\n      globalNamespace.push(globalPrefix);\n      counterNamespace.push(globalPrefix);\n      timerNamespace.push(globalPrefix);\n      gaugesNamespace.push(globalPrefix);\n      setsNamespace.push(globalPrefix);\n    }\n\n    if (prefixCounter !== \"\") {\n      counterNamespace.push(prefixCounter);\n    }\n    if (prefixTimer !== \"\") {\n      timerNamespace.push(prefixTimer);\n    }\n    if (prefixGauge !== \"\") {\n      gaugesNamespace.push(prefixGauge);\n    }\n    if (prefixSet !== \"\") {\n      setsNamespace.push(prefixSet);\n    }\n  } else {\n      globalNamespace = ['stats'];\n      counterNamespace = ['stats'];\n      timerNamespace = ['stats', 'timers'];\n      gaugesNamespace = ['stats', 'gauges'];\n      setsNamespace = ['stats', 'sets'];\n  }\n\n  graphiteStats.last_flush = startup_time;\n  graphiteStats.last_exception = startup_time;\n  graphiteStats.flush_time = 0;\n  graphiteStats.flush_length = 0;\n\n  if (config.keyNameSanitize !== undefined) {\n    globalKeySanitize = config.keyNameSanitize;\n  }\n\n  flushInterval = config.flushInterval;\n\n  flush_counts = typeof(config.flush_counts) === \"undefined\" ? true : config.flush_counts;\n\n  events.on('flush', flush_stats);\n  events.on('status', backend_status);\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/backends/repeater.js":"/*jshint node:true, laxcomma:true */\n\nvar util = require('util')\n  , dgram = require('dgram')\n  , logger = require('../lib/logger')\n  , Pool = require('generic-pool').Pool\n  , net = require('net');\n\n\nvar l;\nvar debug;\nvar instance;\n\nfunction logerror(err) {\n  if(err && debug) {\n    l.log(err);\n  }\n}\n\n\n\nfunction UDPRepeaterBackend(startupTime, config, emitter) {\n  var self = this;\n  this.config = config.repeater || [];\n  this.sock = (config.repeaterProtocol == 'udp6') ?\n        dgram.createSocket('udp6') :\n        dgram.createSocket('udp4');\n\n  // Attach DNS error handler\n  this.sock.on('error', function (err) {\n    if (debug) {\n      l.log('Repeater error: ' + err);\n    }\n  });\n\n  // attach\n  emitter.on('packet', function(packet, rinfo) { self.process(packet, rinfo); });\n}\n\n\nUDPRepeaterBackend.prototype.process = function(packet, rinfo) {\n  var self = this;\n  var hosts = self.config;\n  for(var i=0; i<hosts.length; i++) {\n    self.sock.send(packet,0,packet.length,hosts[i].port,hosts[i].host,logerror);\n  }\n};\n\nUDPRepeaterBackend.prototype.stop = function(cb) {\n  this.sock.close();\n  cb();\n};\n\n\n\nvar TCPRepeaterBackend = function(startupTime, config, emitter) {  \n  this.config = config;\n  this.pools = [];\n  \n  var targets = this.config.repeater || [];\n  for(var i = 0; i < targets.length; i++) {\n    this.pools.push(this.createPool(targets[i]));\n  }\n\n  var self = this;\n  emitter.on('packet', function(packet, rinfo) { self.process(packet, rinfo); });\n};\n\n\nTCPRepeaterBackend.prototype.createPool = function(server) {  \n  return Pool({\n    name: server.host + ':' + server.port,\n\n    create: function(cb) {\n      var client = net.connect(server.port, server.host);\n\n      function connectError(err) { cb(err, null); }\n\n      client.on('connect', function() {\n        client.removeListener('error', connectError);\n        cb(null, client);\n      });\n      \n      client.on('error', connectError);\n    },\n\n    destroy: function(client) {\n      client.end();\n    },\n\n    max: 5\n  });\n};\n\nTCPRepeaterBackend.prototype.process = function(packet, rinfo) {\n  function send(buf, pool) {\n    pool.acquire(function(err, client) {\n      if(err) {\n        logerror(err);\n      } else {\n        client.write(buf, function() {\n          pool.release(client);\n        });\n      }\n    });\n  }\n\n  for(var i = 0; i < this.pools.length; i++) {\n    send(new Buffer(packet.toString() + \"\\n\"), this.pools[i]);\n  }\n};\n\n\nTCPRepeaterBackend.prototype.stop = function(cb) {\n  var self = this;\n  function drain_pool(i) {\n    if(i == self.pools.length) {\n      cb();\n      return;\n    }\n\n    self.pools[i].drain(function() {\n      self.pools[i].destroyAllNow(function() {\n        drain_pool(i + 1);\n      });\n    });\n  }\n  \n  drain_pool(0);\n};\n\n\nexports.init = function(startupTime, config, emitter, logger) {\n  debug = config.debug;\n  l = logger;\n\n  var proto = config.repeaterProtocol;\n  if(proto == 'tcp') {\n    instance = new TCPRepeaterBackend(startupTime, config, emitter);\n  } else {\n    instance = new UDPRepeaterBackend(startupTime, config, emitter);\n  }\n\n  return true;\n};\n\n\nexports.stop = function(cb) {\n  if(instance) {\n    instance.stop(cb);\n    instance = null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/logger.js":"/*jshint node:true, laxcomma:true */\n\nvar Logger = function (config) {\n  this.config  = config;\n  this.backend = this.config.backend || 'stdout';\n  this.level   = this.config.level || \"LOG_INFO\";\n  if (this.backend == 'stdout') {\n    this.util = require('util');\n  } else {\n    if (this.backend == 'syslog') {\n      this.util = require('modern-syslog');\n      this.util.init(config.application || 'statsd', this.util.LOG_PID | this.util.LOG_ODELAY, this.util.LOG_LOCAL0);\n    } else {\n      throw \"Logger: Should be 'stdout' or 'syslog'.\";\n    }\n  }\n};\n\nLogger.prototype = {\n  log: function (msg, type) {\n    if (this.backend == 'stdout') {\n      if (!type) {\n        type = 'DEBUG';\n      }\n      this.util.log(type + \": \" + msg);\n    } else {\n      var level;\n      if (!type) {\n        level = this.level;\n      } else {\n        level = \"LOG_\" + type.toUpperCase();\n      }\n\n      if (!this.util[level]) {\n        throw \"Undefined log level: \" + level;\n      }\n\n      this.util.log(this.util[level], msg);\n    }\n  }\n};\n\nexports.Logger = Logger;\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/debian/localConfig.js":"{\n  graphitePort: 2003\n, graphiteHost: \"localhost\"\n, port: 8125\n}\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/debian/proxyConfig.js":"{\nnodes: [\n{host: 'localhost', port: 8125, adminport: 8126},\n],\nudp_version: 'udp4',\nhost:  '0.0.0.0',\nport: 8127,\nforkCount: 0,\ncheckInterval: 1000,\ncacheSize: 10000\n}\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/exampleConfig.js":"/*\nGraphite Required Variable:\n\n(Leave this unset to avoid sending stats to Graphite.\n Set debug flag and leave this unset to run in 'dry' debug mode -\n useful for testing statsd clients without a Graphite server.)\n\n  graphiteHost:     hostname or IP of Graphite server\n\nOptional Variables:\n\n  graphitePort:     port for the graphite text collector [default: 2003]\n  graphitePicklePort: port for the graphite pickle collector [default: 2004]\n  graphiteProtocol: either 'text' or 'pickle' [default: 'text']\n  backends:         an array of backends to load. Each backend must exist\n                    by name in the directory backends/. If not specified,\n                    the default graphite backend will be loaded. \n                    * example for console and graphite:\n                    [ \"./backends/console\", \"./backends/graphite\" ]\n\n  servers:          an array of server configurations.\n                    If not specified, the server, address,\n                    address_ipv6, and port top-level configuration\n                    options are used to configure a single server for\n                    backwards-compatibility\n                    Each server configuration supports the following keys:\n    server:         the server to load. The server must exist by name in the directory\n                    servers/. If not specified, the default udp server will be loaded.\n                    * example for tcp server:\n                    \"./servers/tcp\"\n    address:        address to listen on [default: 0.0.0.0]\n    address_ipv6:   defines if the address is an IPv4 or IPv6 address [true or false, default: false]\n    port:           port to listen for messages on [default: 8125]\n    socket:         (only for tcp servers) path to unix domain socket which will be used to receive\n                    metrics [default: undefinded]\n    socket_mod:     (only for tcp servers) file mode which should be applied to unix domain socket, relevant\n                    only if socket option is used [default: undefined]\n\n  debug:            debug flag [default: false]\n  mgmt_address:     address to run the management TCP interface on\n                    [default: 0.0.0.0]\n  mgmt_port:        port to run the management TCP interface on [default: 8126]\n  title:            Allows for overriding the process title. [default: statsd]\n                    if set to false, will not override the process title and let the OS set it.\n                    The length of the title has to be less than or equal to the binary name + cli arguments\n                    NOTE: This does not work on Mac's with node versions prior to v0.10\n\n  healthStatus:     default health status to be returned and statsd process starts ['up' or 'down', default: 'up']\n  dumpMessages:     log all incoming messages\n  flushInterval:    interval (in ms) to flush metrics to each backend\n  percentThreshold: for time information, calculate the Nth percentile(s)\n                    (can be a single value or list of floating-point values)\n                    negative values mean to use \"top\" Nth percentile(s) values\n                    [%, default: 90]\n  flush_counts:     send stats_counts metrics [default: true]\n\n  keyFlush:         log the most frequently sent keys [object, default: undefined]\n    interval:       how often to log frequent keys [ms, default: 0]\n    percent:        percentage of frequent keys to log [%, default: 100]\n    log:            location of log file for frequent keys [default: STDOUT]\n  deleteIdleStats:  don't send values to graphite for inactive counters, sets, gauges, or timers\n                    as opposed to sending 0.  For gauges, this unsets the gauge (instead of sending\n                    the previous value). Can be individually overriden. [default: false]\n  deleteGauges:     don't send values to graphite for inactive gauges, as opposed to sending the previous value [default: false]\n  deleteTimers:     don't send values to graphite for inactive timers, as opposed to sending 0 [default: false]\n  deleteSets:       don't send values to graphite for inactive sets, as opposed to sending 0 [default: false]\n  deleteCounters:   don't send values to graphite for inactive counters, as opposed to sending 0 [default: false]\n  prefixStats:      prefix to use for the statsd statistics data for this running instance of statsd [default: statsd]\n                    applies to both legacy and new namespacing\n  keyNameSanitize:  sanitize all stat names on ingress [default: true]\n                    If disabled, it is up to the backends to sanitize keynames\n                    as appropriate per their storage requirements.\n\n  console:\n    prettyprint:    whether to prettyprint the console backend\n                    output [true or false, default: true]\n\n  log:              log settings [object, default: undefined]\n    backend:        where to log: stdout or syslog [string, default: stdout]\n    application:    name of the application for syslog [string, default: statsd]\n    level:          log level for [node-]syslog [string, default: LOG_INFO]\n\n  graphite:\n    legacyNamespace:  use the legacy namespace [default: true]\n    globalPrefix:     global prefix to use for sending stats to graphite [default: \"stats\"]\n    prefixCounter:    graphite prefix for counter metrics [default: \"counters\"]\n    prefixTimer:      graphite prefix for timer metrics [default: \"timers\"]\n    prefixGauge:      graphite prefix for gauge metrics [default: \"gauges\"]\n    prefixSet:        graphite prefix for set metrics [default: \"sets\"]\n    globalSuffix:     global suffix to use for sending stats to graphite [default: \"\"]\n                      This is particularly useful for sending per host stats by\n                      settings this value to: require('os').hostname().split('.')[0]\n\n  repeater:         an array of hashes of the for host: and port:\n                    that details other statsd servers to which the received\n                    packets should be \"repeated\" (duplicated to).\n                    e.g. [ { host: '10.10.10.10', port: 8125 },\n                           { host: 'observer', port: 88125 } ]\n\n  repeaterProtocol: whether to use udp4, udp6, or tcp for repeaters.\n                    [\"udp4,\" \"udp6\", or \"tcp\" default: \"udp4\"]\n\n  histogram:        for timers, an array of mappings of strings (to match metrics) and\n                    corresponding ordered non-inclusive upper limits of bins.\n                    For all matching metrics, histograms are maintained over\n                    time by writing the frequencies for all bins.\n                    'inf' means infinity. A lower limit of 0 is assumed.\n                    default: [], meaning no histograms for any timer.\n                    First match wins.  examples:\n                    * histogram to only track render durations, with unequal\n                      class intervals and catchall for outliers:\n                      [ { metric: 'render', bins: [ 0.01, 0.1, 1, 10, 'inf'] } ]\n                    * histogram for all timers except 'foo' related,\n                      equal class interval and catchall for outliers:\n                     [ { metric: 'foo', bins: [] },\n                       { metric: '', bins: [ 50, 100, 150, 200, 'inf'] } ]\n\n  automaticConfigReload: whether to watch the config file and reload it when it\n                         changes. The default is true. Set this to false to disable.\n*/\n{\n  graphitePort: 2003\n, graphiteHost: \"graphite.example.com\"\n, port: 8125\n, backends: [ \"./backends/graphite\" ]\n}\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/exampleProxyConfig.js":"/*\n\nRequired Variables:\n\n  port:             StatsD Cluster Proxy listening port [default: 8125]\n  mgmt_port:        StatsD Cluster Proxy telnet management port [default: 8126]\n  mgmt_address:     address to run the management TCP interface on [default: 0.0.0.0]\n  nodes:            list of StatsD instances\n     host:          address of an instance of StatsD\n     port:          port that this instance is listening on\n     adminport:     port that this instance is listening on for the admininterface\n\nOptional Variables:\n\n  host:             address to listen on over UDP [default: 0.0.0.0]\n  address_ipv6:     defines if the listen address is an IPv4 or IPv6 address [true or false, default: false]\n  checkInterval:    health status check interval [default: 10000]\n  cacheSize:        size of the cache to store for hashring key lookups [default: 10000]\n  forkCount:        number of child processes (cluster module), number or 'auto' for utilize all cpus [default:0]\n  server:           the server to load. The server must exist by name in the directory\n                    servers/. If not specified, the default udp server will be loaded.\n                    Note: This will still send to the backends via udp regardless of the\n                    server type for the proxy\n                    * example for tcp server:\n                    \"./servers/tcp\"\n\n*/\n{\nnodes: [\n{host: '127.0.0.1', port: 8127, adminport: 8128},\n{host: '127.0.0.1', port: 8129, adminport: 8130},\n{host: '127.0.0.1', port: 8131, adminport: 8132}\n],\nserver: './servers/udp',\nhost:  '0.0.0.0',\nport: 8125,\nmgmt_port: 8126,\nforkCount: 0,\ncheckInterval: 1000,\ncacheSize: 10000\n}\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/config.js":"/*jshint node:true, laxcomma:true */\n\nvar fs  = require('fs')\n  , util = require('util');\n\nvar Configurator = function (file) {\n\n  var self = this;\n  var config = {};\n  var oldConfig = {};\n\n  this.updateConfig = function () {\n    util.log('[' + process.pid + '] reading config file: ' + file);\n\n    fs.readFile(file, function (err, data) {\n      if (err) { throw err; }\n      old_config = self.config;\n\n      self.config = eval('config = ' + data);\n      self.emit('configChanged', self.config);\n    });\n  };\n\n  this.updateConfig();\n\n  fs.watch(file, function (event, filename) {\n    if (event == 'change' && self.config.automaticConfigReload != false) {\n      self.updateConfig();\n    }\n  });\n};\n\nutil.inherits(Configurator, process.EventEmitter);\n\nexports.Configurator = Configurator;\n\nexports.configFile = function(file, callbackFunc) {\n  var config = new Configurator(file);\n  config.on('configChanged', function() {\n    callbackFunc(config.config, config.oldConfig);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/helpers.js":"/**\n * Public: test function to filter out malformed packets\n *\n * Parameters:\n *\n *   fields - Array of packet data (e.g. [ '100', 'ms', '@0.1' ])\n *\n * Returns true for a valid packet and false otherwise\n */\nfunction isNumber(str) {\n    return Boolean(str && !isNaN(str));\n}\n\nfunction isValidSampleRate(str) {\n    var validSampleRate = false;\n    if(str.length > 1 && str[0] === '@') {\n        var numberStr = str.substring(1);\n        validSampleRate = isNumber(numberStr) && numberStr[0] != '-';\n    }\n    return validSampleRate;\n}\n\nfunction is_valid_packet(fields) {\n\n    // test for existing metrics type\n    if (fields[1] === undefined) {\n        return false;\n    }\n\n    // filter out malformed sample rates\n    if(fields[2] !== undefined) {\n        if(!isValidSampleRate(fields[2])) {\n            return false;\n        }\n    }\n\n    // filter out invalid metrics values\n    switch(fields[1]) {\n        case 's':\n            return true;\n        case 'g':\n            return isNumber(fields[0]);\n        case 'ms':\n            return isNumber(fields[0]) && Number(fields[0]) >= 0;\n        default:\n            if (!isNumber(fields[0])) {\n                return false;\n            }\n            return true;\n    }\n\n}\n\nexports.is_valid_packet = is_valid_packet;\n\nexports.writeConfig = function(config, stream) {\n  stream.write(\"\\n\");\n  for (var prop in config) {\n    if (!config.hasOwnProperty(prop)) {\n      continue;\n    }\n    if (typeof config[prop] !== 'object') {\n      stream.write(prop + \": \" + config[prop] + \"\\n\");\n      continue;\n    }\n    var subconfig = config[prop];\n    for (var subprop in subconfig) {\n      if (!subconfig.hasOwnProperty(subprop)) {\n        continue;\n      }\n      stream.write(prop + \" > \" + subprop + \": \" + subconfig[subprop] + \"\\n\");\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/mgmt_console.js":"/*jshint node:true, laxcomma:true */\n\n/**\n * delete_stats - delete all matching statistics\n *\n * Side effect notes: this function works by altering stats_type in place,\n *   and calls stream.write(str) to display user feedback.\n *\n * @param stats_type array of all statistics of this type (eg~ timers) to delete from\n * @param cmdline array of all requested deletions, which can be fully qualified,\n *   or end in a .* to delete a folder, like stats.temp.*\n * @param stream buffer output for for all outgoing user feedback\n */\nexports.delete_stats = function(stats_type, cmdline, stream) {\n\n  //for each metric requested on the command line\n  for (var index in cmdline) {\n\n    //get a list of deletable metrics that match the request\n    deletable = existing_stats(stats_type, cmdline[index]);\n\n    //warn if no matches\n    if (deletable.length === 0) {\n      stream.write(\"metric \" + cmdline[index] + \" not found\\n\");\n    }\n\n    //delete all requested metrics\n    for (var del_idx in deletable) {\n      delete stats_type[deletable[del_idx]];\n      stream.write(\"deleted: \" + deletable[del_idx] + \"\\n\");\n    }\n  }\n  stream.write(\"END\\n\\n\");\n};\n\n/**\n * existing_stats - find fully qualified matches for the requested stats bucket\n *\n * @param stats_type array of all statistics of this type (eg~ timers) to match\n * @param bucket string to search on, which can be fully qualified,\n *   or end in a .* to search for a folder, like stats.temp.*\n *\n * @return array of fully qualified stats that match the specified bucket. if\n *   no matches, an empty array is a valid response\n */\nfunction existing_stats(stats_type, bucket){\n  matches = [];\n\n  //typical case: one-off, fully qualified\n  if (bucket in stats_type) {\n    matches.push(bucket);\n  }\n\n  //special case: match a whole 'folder' (and subfolders) of stats\n  if (bucket.slice(-2) == \".*\") {\n    var folder = bucket.slice(0,-1);\n\n    for (var name in stats_type) {\n      //check if stat is in bucket, ie~ name starts with folder\n      if (name.substring(0, folder.length) == folder) {\n        matches.push(name);\n      }\n    }\n  }\n\n  return matches;\n}\n\nexports.existing_stats = existing_stats;\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/mgmt_server.js":"/*jshint node:true, laxcomma:true */\n\nvar net = require('net');\n\nexports.start = function(config, on_data_callback, on_error_callback) {\n  var server = net.createServer(function(stream) {\n      stream.setEncoding('ascii');\n\n      stream.on('data', function(data) {\n        var cmdline = data.trim().split(\" \");\n        var cmd = cmdline.shift();\n\n        on_data_callback(cmd, cmdline, stream);\n      });\n\n      stream.on('error', function(err) {\n        on_error_callback(err, stream);\n      });\n  });\n\n  server.listen(config.mgmt_port || 8126, config.mgmt_address || undefined);\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/process_metrics.js":"/*jshint node:true, laxcomma:true */\n\nvar process_metrics = function (metrics, flushInterval, ts, flushCallback) {\n    var starttime = Date.now();\n    var key;\n    var counter_rates = {};\n    var timer_data = {};\n    var statsd_metrics = {};\n    var counters = metrics.counters;\n    var timers = metrics.timers;\n    var timer_counters = metrics.timer_counters;\n    var pctThreshold = metrics.pctThreshold;\n    var histogram = metrics.histogram;\n\n    for (key in counters) {\n      var value = counters[key];\n\n      // calculate \"per second\" rate\n      counter_rates[key] = value / (flushInterval / 1000);\n    }\n\n    for (key in timers) {\n      var current_timer_data = {};\n\n      if (timers[key].length > 0) {\n        timer_data[key] = {};\n\n        var values = timers[key].sort(function (a,b) { return a-b; });\n        var count = values.length;\n        var min = values[0];\n        var max = values[count - 1];\n\n        var cumulativeValues = [min];\n        var cumulSumSquaresValues = [min * min];\n        for (var i = 1; i < count; i++) {\n            cumulativeValues.push(values[i] + cumulativeValues[i-1]);\n            cumulSumSquaresValues.push((values[i] * values[i]) +\n                                       cumulSumSquaresValues[i - 1]);\n        }\n\n        var sum = min;\n        var sumSquares = min * min;\n        var mean = min;\n        var thresholdBoundary = max;\n\n        var key2;\n\n        for (key2 in pctThreshold) {\n          var pct = pctThreshold[key2];\n          var numInThreshold = count;\n\n          if (count > 1) {\n            numInThreshold = Math.round(Math.abs(pct) / 100 * count);\n            if (numInThreshold === 0) {\n              continue;\n            }\n\n            if (pct > 0) {\n              thresholdBoundary = values[numInThreshold - 1];\n              sum = cumulativeValues[numInThreshold - 1];\n              sumSquares = cumulSumSquaresValues[numInThreshold - 1];\n            } else {\n              thresholdBoundary = values[count - numInThreshold];\n              sum = cumulativeValues[count - 1] - cumulativeValues[count - numInThreshold - 1];\n              sumSquares = cumulSumSquaresValues[count - 1] -\n                cumulSumSquaresValues[count - numInThreshold - 1];\n            }\n            mean = sum / numInThreshold;\n          }\n\n          var clean_pct = '' + pct;\n          clean_pct = clean_pct.replace('.', '_').replace('-', 'top');\n          current_timer_data[\"count_\" + clean_pct] = numInThreshold;\n          current_timer_data[\"mean_\" + clean_pct] = mean;\n          current_timer_data[(pct > 0 ? \"upper_\" : \"lower_\") + clean_pct] = thresholdBoundary;\n          current_timer_data[\"sum_\" + clean_pct] = sum;\n          current_timer_data[\"sum_squares_\" + clean_pct] = sumSquares;\n\n        }\n\n        sum = cumulativeValues[count-1];\n        sumSquares = cumulSumSquaresValues[count-1];\n        mean = sum / count;\n\n        var sumOfDiffs = 0;\n        for (var i = 0; i < count; i++) {\n           sumOfDiffs += (values[i] - mean) * (values[i] - mean);\n        }\n\n        var mid = Math.floor(count/2);\n        var median = (count % 2) ? values[mid] : (values[mid-1] + values[mid])/2;\n\n        var stddev = Math.sqrt(sumOfDiffs / count);\n        current_timer_data[\"std\"] = stddev;\n        current_timer_data[\"upper\"] = max;\n        current_timer_data[\"lower\"] = min;\n        current_timer_data[\"count\"] = timer_counters[key];\n        current_timer_data[\"count_ps\"] = timer_counters[key] / (flushInterval / 1000);\n        current_timer_data[\"sum\"] = sum;\n        current_timer_data[\"sum_squares\"] = sumSquares;\n        current_timer_data[\"mean\"] = mean;\n        current_timer_data[\"median\"] = median;\n\n        // note: values bigger than the upper limit of the last bin are ignored, by design\n        conf = histogram || [];\n        bins = [];\n        for (var i = 0; i < conf.length; i++) {\n            if (key.indexOf(conf[i].metric) > -1) {\n                bins = conf[i].bins;\n                break;\n            }\n        }\n        if(bins.length) {\n            current_timer_data['histogram'] = {};\n        }\n        // the outer loop iterates bins, the inner loop iterates timer values;\n        // within each run of the inner loop we should only consider the timer value range that's within the scope of the current bin\n        // so we leverage the fact that the values are already sorted to end up with only full 1 iteration of the entire values range\n        var i = 0;\n        for (var bin_i = 0; bin_i < bins.length; bin_i++) {\n          var freq = 0;\n          for (; i < count && (bins[bin_i] == 'inf' || values[i] < bins[bin_i]); i++) {\n            freq += 1;\n          }\n          bin_name = 'bin_' + bins[bin_i].toString().replace('.', '_');\n          current_timer_data['histogram'][bin_name] = freq;\n        }\n\n      } else {\n\n        current_timer_data[\"count\"] = current_timer_data[\"count_ps\"] = 0;\n\n      }\n\n      timer_data[key] = current_timer_data;\n    }\n\n    statsd_metrics[\"processing_time\"] = (Date.now() - starttime);\n    //add processed metrics to the metrics_hash\n    metrics.counter_rates = counter_rates;\n    metrics.timer_data = timer_data;\n    metrics.statsd_metrics = statsd_metrics;\n\n    flushCallback(metrics);\n  };\n\nexports.process_metrics = process_metrics;\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/process_mgmt.js":"var util = require('util');\n\nvar conf;\n\nexports.init = function(config) {\n  conf = config;\n  exports.set_title(config);\n\n  process.on('SIGTERM', function() {\n   if (conf.debug) {\n     util.log('Starting Final Flush');\n   }\n   healthStatus = 'down';\n   process.exit();\n  });\n\n}\n\nexports.set_title = function(config) {\n if (config.title !== undefined) {\n   if (config.title) {\n       process.title = config.title;\n   }\n } else {\n   // Respect command line arguments when overriding the process title.\n   cmdline = process.argv.slice(2);\n   cmdline.unshift('statsd');\n\n   process.title = cmdline.join(\" \");\n }\n}\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/lib/set.js":"/*jshint node:true, laxcomma:true */\n\nvar Set = function() {\n  this.store = {};\n};\n\nSet.prototype = {\n  has: function(value) {\n    if (value) {\n      return this.store.hasOwnProperty(value);\n    } else {\n      return false;\n    }\n  },\n  insert: function(value) {\n    if (value) {\n      this.store[value] = true;\n    }\n  },\n  clear: function() {\n    this.store = {};\n  },\n  values: function() {\n    var values = [];\n    for (var value in this.store) {\n      values.push(value);\n    }\n    return values;\n  },\n  size: function() {\n    return Object.keys(this.store).length;\n  }\n};\n\nexports.Set = Set;\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/proxy.js":"/*jshint node:true, laxcomma:true */\n\nvar dgram    = require('dgram')\n  , net      = require('net')\n  , events   = require('events')\n  , logger = require('./lib/logger')\n  , hashring = require('hashring')\n  , cluster = require('cluster')\n  , helpers = require('./lib/helpers')\n  , mgmt_server = require('./lib/mgmt_server')\n  , configlib   = require('./lib/config');\n\nvar packet   = new events.EventEmitter();\nvar startup_time = Math.round(new Date().getTime() / 1000);\nvar node_status = [];\nvar workers = [];  // Keep track of all forked childs\nvar node_ring = {};\nvar servers_loaded;\nvar config;\nvar l;  // logger\n\nconfiglib.configFile(process.argv[2], function (conf, oldConfig) {\n  config = conf;\n  var udp_version = config.address_ipv6 ? 'udp6' : 'udp4';\n  var nodes = config.nodes;\n  l = new logger.Logger(config.log || {});\n\n  var forkCount = config.forkCount;\n  if (forkCount === 'auto') {\n    forkCount = require('os').cpus().length;\n  }\n\n  var logPrefix = \"[\" + process.pid + \"] \";\n  var log = function(msg, type) {\n    l.log(logPrefix + msg, type);\n  };\n\n  var healthStatus = configlib.healthStatus || 'up';\n  var broadcastMsg = function(msg) {\n    for (var i = 0; i < workers.length; i++) {\n      workers[i].send(msg);\n    }\n  };\n\n  if (forkCount > 1) {\n    if (cluster.isMaster) {\n      var worker;\n      logPrefix += \"[master] \";\n      log(\"forking \" + forkCount + \" childs\", \"INFO\");\n\n      for (var i = 0; i < forkCount; i++) {\n        worker = cluster.fork();\n        worker.on('message', broadcastMsg);\n      }\n\n      cluster.on('online', function(worker) {\n        log('worker ' + worker.process.pid + ' is online', 'INFO');\n        workers.push(worker);\n      });\n\n      cluster.on('exit', function(worker, code, signal) {\n        log('worker ' + worker.process.pid + ' died with exit code:' + code + \" restarting\", 'ERROR');\n\n        // Remove died worker from the array\n        for (var i = 0; i < workers.length; i++) {\n          if (workers[i].process.pid == worker.process.pid) {\n            workers.splice(i, 1);\n          }\n        }\n\n        worker = cluster.fork();\n        worker.on('message', broadcastMsg);\n      });\n\n      return;\n\n    } else {\n      process.on('message', function(msg) {\n        if (msg.healthStatus) {\n          healthStatus = msg.healthStatus;\n        }\n      });\n    }\n  }\n\n  //load the node_ring object with the available nodes and a weight of 100\n  // weight is currently arbitrary but the same for all\n  nodes.forEach(function(element, index, array) {\n    node_ring[element.host + ':' + element.port] = 100;\n  });\n\n  var ring = new hashring(\n    node_ring, 'md5', {\n      'max cache size': config.cacheSize || 10000,\n      //We don't want duplicate keys sent so replicas set to 0\n      'replicas': 0\n    });\n\n  if (!servers_loaded) {\n    // Do an initial rount of health checks prior to starting up the server\n    doHealthChecks();\n\n    // Setup the udp listener\n    var server_config = config.server  || './servers/udp';\n    var servermod = require(server_config);\n    var server = servermod.start(config, function (msg, rinfo) {\n      // Convert the raw packet to a string (defaults to UTF8 encoding)\n      var packet_data = msg.toString();\n      var current_metric\n        , bits\n        , key;\n      // If the packet contains a \\n then it contains multiple metrics\n      if (packet_data.indexOf(\"\\n\") > -1) {\n        var metrics;\n        metrics = packet_data.split(\"\\n\");\n        // Loop through the metrics and split on : to get mertric name for hashing\n        for (var midx in metrics) {\n          current_metric = metrics[midx];\n          bits = current_metric.split(':');\n          key = bits.shift();\n          if (current_metric !== '') {\n            var new_msg = new Buffer(current_metric);\n            packet.emit('send', key, new_msg);\n          }\n        }\n\n      } else {\n        // metrics needs to be an array to fake it for single metric packets\n        current_metric = packet_data;\n        bits = current_metric.split(':');\n        key = bits.shift();\n        if (current_metric !== '') {\n          packet.emit('send', key, msg);\n        }\n      }\n    });\n    var client = dgram.createSocket(udp_version);\n    // Listen for the send message, and process the metric key and msg\n    packet.on('send', function(key, msg) {\n      // retreives the destination for this key\n      var statsd_host = ring.get(key);\n\n      // break the retreived host to pass to the send function\n      if (statsd_host === undefined) {\n        log('Warning: No backend statsd nodes available!', 'WARNING');\n      } else {\n        var host_config = statsd_host.split(':');\n\n        // Send the mesg to the backend\n        client.send(msg, 0, msg.length, host_config[1], host_config[0]);\n      }\n    });\n\n    mgmt_server.start(\n      config,\n      function(cmd, parameters, stream) {\n        switch(cmd) {\n          case \"help\":\n            stream.write(\"Commands: config, health, status, quit\\n\\n\");\n            break;\n\n          case \"config\":\n            helpers.writeConfig(config, stream);\n            break;\n\n          case \"health\":\n            if (parameters.length > 0) {\n              var cmdaction = parameters[0].toLowerCase();\n              if (cmdaction === 'up') {\n                healthStatus = 'up';\n                if (forkCount > 0) {\n                  // Notify the other forks\n                  process.send({ healthStatus: healthStatus });\n                }\n              } else if (cmdaction === 'down') {\n                healthStatus = 'down';\n                if (forkCount > 0) {\n                  // Notify the other forks\n                  process.send({ healthStatus: healthStatus });\n                }\n              }\n            }\n            stream.write(\"health: \" + healthStatus + \"\\n\");\n            break;\n\n          case \"status\":\n            var now    = Math.round(new Date().getTime() / 1000);\n            var uptime = now - startup_time;\n\n            stream.write(\"uptime: \" + uptime + \"\\n\");\n\n            stream.write(\"nodes: \");\n            ring.servers.forEach(function(server, index, array) {\n              stream.write(server.string + \" \");\n            });\n            stream.write(\"\\n\");\n            break;\n\n          case \"quit\":\n            stream.end();\n            break;\n\n          default:\n            stream.write(\"ERROR\\n\");\n            break;\n        }\n      },\n      function(err, stream) {\n        log(\"MGMT: Caught \" + err + \", Moving on\", \"WARNING\");\n      }\n    );\n\n    servers_loaded = true;\n    log(\"server is up\", \"INFO\");\n\n    // Set the interval for healthchecks\n    setInterval(doHealthChecks, config.checkInterval || 10000);\n  }\n\n  // Perform health check on all nodes\n  function doHealthChecks() {\n    nodes.forEach(function(element, index, array) {\n      healthcheck(element);\n    });\n  }\n\n  // Perform health check on node\n  function healthcheck(node) {\n    var node_id = node.host + ':' + node.port;\n    var client = net.connect({port: node.adminport, host: node.host},\n        function() {\n      client.write('health\\r\\n');\n    });\n    client.on('data', function(data) {\n      var health_status = data.toString();\n      client.end();\n      if (health_status.indexOf('up') < 0) {\n        if (node_status[node_id] === undefined) {\n          node_status[node_id] = 1;\n        } else {\n          node_status[node_id]++;\n        }\n        if (node_status[node_id] < 2) {\n          log('Removing node ' + node_id + ' from the ring.', 'WARNING');\n          ring.remove(node_id);\n        }\n      } else {\n        if (node_status[node_id] !== undefined) {\n          if (node_status[node_id] > 0) {\n            var new_server = {};\n            new_server[node_id] = 100;\n            log('Adding node ' + node_id + ' to the ring.', 'WARNING');\n            ring.add(new_server);\n          }\n        }\n        node_status[node_id] = 0;\n      }\n    });\n    client.on('error', function(e) {\n      if (e.code == 'ECONNREFUSED') {\n        if (node_status[node_id] === undefined) {\n          node_status[node_id] = 1;\n        } else {\n          node_status[node_id]++;\n        }\n        if (node_status[node_id] < 2) {\n          log('Removing node ' + node_id + ' from the ring.', 'WARNING');\n          ring.remove(node_id);\n        }\n      } else {\n        log('Error during healthcheck on node ' + node_id + ' with ' + e.code, 'ERROR');\n      }\n    });\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/servers/tcp.js":"var net  = require('net');\nvar fs = require('fs');\n\nfunction rinfo(tcpstream, data) {\n    this.address = tcpstream.remoteAddress;\n    this.port = tcpstream.remotePort;\n    this.family = tcpstream.address() ? tcpstream.address().family : 'IPv4';\n    this.size = data.length;\n}\n\nexports.start = function(config, callback) {\n  var server = net.createServer(function(stream) {\n      stream.setEncoding('ascii');\n\n      var buffer = '';\n      stream.on('data', function(data) {\n          buffer += data;\n          var offset = buffer.lastIndexOf(\"\\n\");\n          if (offset > -1) {\n             var packet = buffer.slice(0, offset + 1);\n             buffer = buffer.slice(offset + 1);\n             callback(packet, new rinfo(stream, packet));\n          }\n      });\n  });\n\n  server.on('listening', function() {\n    config.socket && config.socket_mod && fs.chmod(config.socket, config.socket_mod);\n  });\n\n  process.on('exit', function() {\n      config.socket && fs.unlinkSync(config.socket);\n  });\n\n  server.listen(config.socket || config.port || 8125, config.address || undefined);\n  this.server = server;\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/servers/udp.js":"var dgram  = require('dgram');\n\nexports.start = function(config, callback) {\n  var udp_version = config.address_ipv6 ? 'udp6' : 'udp4';\n  var server = dgram.createSocket(udp_version, callback);\n\n  server.bind(config.port || 8125, config.address || undefined);\n  this.server = server;\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-statsd/node_modules/statsd/stats.js":"/*jshint node:true, laxcomma:true */\n\nvar util    = require('util')\n  , config = require('./lib/config')\n  , helpers = require('./lib/helpers')\n  , fs     = require('fs')\n  , events = require('events')\n  , logger = require('./lib/logger')\n  , set = require('./lib/set')\n  , pm = require('./lib/process_metrics')\n  , process_mgmt = require('./lib/process_mgmt')\n  , mgmt_server = require('./lib/mgmt_server')\n  , mgmt = require('./lib/mgmt_console');\n\n\n// initialize data structures with defaults for statsd stats\nvar keyCounter = {};\nvar counters = {};\nvar timers = {};\nvar timer_counters = {};\nvar gauges = {};\nvar sets = {};\nvar counter_rates = {};\nvar timer_data = {};\nvar pctThreshold = null;\nvar flushInterval, keyFlushInt, serversLoaded, mgmtServer;\nvar startup_time = Math.round(new Date().getTime() / 1000);\nvar backendEvents = new events.EventEmitter();\nvar healthStatus = config.healthStatus || 'up';\nvar old_timestamp = 0;\nvar timestamp_lag_namespace;\nvar keyNameSanitize = true;\n\n// Load and init the backend from the backends/ directory.\nfunction loadBackend(config, name) {\n  var backendmod = require(name);\n\n  if (config.debug) {\n    l.log(\"Loading backend: \" + name, 'DEBUG');\n  }\n\n  var ret = backendmod.init(startup_time, config, backendEvents, l);\n  if (!ret) {\n    l.log(\"Failed to load backend: \" + name, \"ERROR\");\n    process.exit(1);\n  }\n}\n\n// Load and init the server from the servers/ directory.\n// The callback mimics the dgram 'message' event parameters (msg, rinfo)\n//   msg: the message received by the server. may contain more than one metric\n//   rinfo: contains remote address information and message length\n//      (attributes are .address, .port, .family, .size - you're welcome)\nfunction startServer(config, name, callback) {\n  var servermod = require(name);\n\n  if (config.debug) {\n    l.log(\"Loading server: \" + name, 'DEBUG');\n  }\n\n  var ret = servermod.start(config, callback);\n  if (!ret) {\n    l.log(\"Failed to load server: \" + name, \"ERROR\");\n    process.exit(1);\n  }\n}\n\n// global for conf\nvar conf;\n\n// Flush metrics to each backend.\nfunction flushMetrics() {\n  var time_stamp = Math.round(new Date().getTime() / 1000);\n  if (old_timestamp > 0) {\n    gauges[timestamp_lag_namespace] = (time_stamp - old_timestamp - (Number(conf.flushInterval)/1000));\n  }\n  old_timestamp = time_stamp;\n\n  var metrics_hash = {\n    counters: counters,\n    gauges: gauges,\n    timers: timers,\n    timer_counters: timer_counters,\n    sets: sets,\n    counter_rates: counter_rates,\n    timer_data: timer_data,\n    pctThreshold: pctThreshold,\n    histogram: conf.histogram\n  };\n\n  // After all listeners, reset the stats\n  backendEvents.once('flush', function clear_metrics(ts, metrics) {\n    // TODO: a lot of this should be moved up into an init/constructor so we don't have to do it every\n    // single flushInterval....\n    // allows us to flag all of these on with a single config but still override them individually\n    conf.deleteIdleStats = conf.deleteIdleStats !== undefined ? conf.deleteIdleStats : false;\n    if (conf.deleteIdleStats) {\n      conf.deleteCounters = conf.deleteCounters !== undefined ? conf.deleteCounters : true;\n      conf.deleteTimers = conf.deleteTimers !== undefined ? conf.deleteTimers : true;\n      conf.deleteSets = conf.deleteSets !== undefined ? conf.deleteSets : true;\n      conf.deleteGauges = conf.deleteGauges !== undefined ? conf.deleteGauges : true;\n    }\n\n    // Clear the counters\n    conf.deleteCounters = conf.deleteCounters || false;\n    for (var counter_key in metrics.counters) {\n      if (conf.deleteCounters) {\n        if ((counter_key.indexOf(\"packets_received\") != -1) ||\n            (counter_key.indexOf(\"metrics_received\") != -1) ||\n            (counter_key.indexOf(\"bad_lines_seen\") != -1)) {\n          metrics.counters[counter_key] = 0;\n        } else {\n         delete(metrics.counters[counter_key]);\n        }\n      } else {\n        metrics.counters[counter_key] = 0;\n      }\n    }\n\n    // Clear the timers\n    conf.deleteTimers = conf.deleteTimers || false;\n    for (var timer_key in metrics.timers) {\n      if (conf.deleteTimers) {\n        delete(metrics.timers[timer_key]);\n        delete(metrics.timer_counters[timer_key]);\n      } else {\n        metrics.timers[timer_key] = [];\n        metrics.timer_counters[timer_key] = 0;\n     }\n    }\n\n    // Clear the sets\n    conf.deleteSets = conf.deleteSets || false;\n    for (var set_key in metrics.sets) {\n      if (conf.deleteSets) {\n        delete(metrics.sets[set_key]);\n      } else {\n        metrics.sets[set_key] = new set.Set();\n      }\n    }\n\n    // Normally gauges are not reset.  so if we don't delete them, continue to persist previous value\n    conf.deleteGauges = conf.deleteGauges || false;\n    if (conf.deleteGauges) {\n      for (var gauge_key in metrics.gauges) {\n        delete(metrics.gauges[gauge_key]);\n      }\n    }\n  });\n\n  pm.process_metrics(metrics_hash, flushInterval, time_stamp, function emitFlush(metrics) {\n    backendEvents.emit('flush', time_stamp, metrics);\n  });\n\n  // Performing this setTimeout at the end of this method rather than the beginning\n  // helps ensure we adapt to negative clock skew by letting the method's latency\n  // introduce a short delay that should more than compensate.\n  setTimeout(flushMetrics, getFlushTimeout(flushInterval));\n}\n\nvar stats = {\n  messages: {\n    last_msg_seen: startup_time,\n    bad_lines_seen: 0\n  }\n};\n\nfunction sanitizeKeyName(key) {\n  if (keyNameSanitize) {\n    return key.replace(/\\s+/g, '_')\n              .replace(/\\//g, '-')\n              .replace(/[^a-zA-Z_\\-0-9\\.]/g, '');\n  } else {\n    return key;\n  }\n}\n\nfunction getFlushTimeout(interval) {\n    return interval - (new Date().getTime() - startup_time * 1000) % flushInterval\n}\n\n// Global for the logger\nvar l;\n\nconfig.configFile(process.argv[2], function (config) {\n  conf = config;\n\n  process_mgmt.init(config);\n\n  l = new logger.Logger(config.log || {});\n\n  // setup config for stats prefix\n  var prefixStats = config.prefixStats;\n  prefixStats = prefixStats !== undefined ? prefixStats : \"statsd\";\n  //setup the names for the stats stored in counters{}\n  bad_lines_seen   = prefixStats + \".bad_lines_seen\";\n  packets_received = prefixStats + \".packets_received\";\n  metrics_received = prefixStats + \".metrics_received\";\n  timestamp_lag_namespace = prefixStats + \".timestamp_lag\";\n\n  //now set to zero so we can increment them\n  counters[bad_lines_seen]   = 0;\n  counters[packets_received] = 0;\n  counters[metrics_received] = 0;\n\n  if (config.keyNameSanitize !== undefined) {\n    keyNameSanitize = config.keyNameSanitize;\n  }\n  if (!serversLoaded) {\n\n    // key counting\n    var keyFlushInterval = Number((config.keyFlush && config.keyFlush.interval) || 0);\n\n    var handlePacket = function (msg, rinfo) {\n      backendEvents.emit('packet', msg, rinfo);\n      counters[packets_received]++;\n      var metrics;\n      var packet_data = msg.toString();\n      if (packet_data.indexOf(\"\\n\") > -1) {\n        metrics = packet_data.split(\"\\n\");\n      } else {\n        metrics = [ packet_data ] ;\n      }\n\n      for (var midx in metrics) {\n        if (metrics[midx].length === 0) {\n          continue;\n        }\n\n        counters[metrics_received]++;\n        if (config.dumpMessages) {\n          l.log(metrics[midx].toString());\n        }\n        var bits = metrics[midx].toString().split(':');\n        var key = sanitizeKeyName(bits.shift());\n\n        if (keyFlushInterval > 0) {\n          if (! keyCounter[key]) {\n            keyCounter[key] = 0;\n          }\n          keyCounter[key] += 1;\n        }\n\n        if (bits.length === 0) {\n          bits.push(\"1\");\n        }\n\n        for (var i = 0; i < bits.length; i++) {\n          var sampleRate = 1;\n          var fields = bits[i].split(\"|\");\n          if (!helpers.is_valid_packet(fields)) {\n              l.log('Bad line: ' + fields + ' in msg \"' + metrics[midx] +'\"');\n              counters[bad_lines_seen]++;\n              stats.messages.bad_lines_seen++;\n              continue;\n          }\n          if (fields[2]) {\n            sampleRate = Number(fields[2].match(/^@([\\d\\.]+)/)[1]);\n          }\n\n          var metric_type = fields[1].trim();\n          if (metric_type === \"ms\") {\n            if (! timers[key]) {\n              timers[key] = [];\n              timer_counters[key] = 0;\n            }\n            timers[key].push(Number(fields[0] || 0));\n            timer_counters[key] += (1 / sampleRate);\n          } else if (metric_type === \"g\") {\n            if (gauges[key] && fields[0].match(/^[-+]/)) {\n              gauges[key] += Number(fields[0] || 0);\n            } else {\n              gauges[key] = Number(fields[0] || 0);\n            }\n          } else if (metric_type === \"s\") {\n            if (! sets[key]) {\n              sets[key] = new set.Set();\n            }\n            sets[key].insert(fields[0] || '0');\n          } else {\n            if (! counters[key]) {\n              counters[key] = 0;\n            }\n            counters[key] += Number(fields[0] || 1) * (1 / sampleRate);\n          }\n        }\n      }\n\n      stats.messages.last_msg_seen = Math.round(new Date().getTime() / 1000);\n    };\n\n    // If config.servers isn't specified, use the top-level config for backwards-compatibility\n    var server_config = config.servers || [config];\n    for (var i = 0; i < server_config.length; i++) {\n      // The default server is UDP\n      var server = server_config[i].server || './servers/udp';\n      startServer(server_config[i], server, handlePacket);\n    }\n\n    mgmt_server.start(\n      config,\n      function(cmd, parameters, stream) {\n        switch(cmd) {\n          case \"help\":\n            stream.write(\"Commands: stats, counters, timers, gauges, delcounters, deltimers, delgauges, health, config, quit\\n\\n\");\n            break;\n\n          case \"config\":\n            helpers.writeConfig(config, stream);\n            break;\n\n          case \"health\":\n            if (parameters.length > 0) {\n              var cmdaction = parameters[0].toLowerCase();\n              if (cmdaction === 'up') {\n                healthStatus = 'up';\n              } else if (cmdaction === 'down') {\n                healthStatus = 'down';\n              }\n            }\n            stream.write(\"health: \" + healthStatus + \"\\n\");\n            break;\n\n          case \"stats\":\n            var now    = Math.round(new Date().getTime() / 1000);\n            var uptime = now - startup_time;\n\n            stream.write(\"uptime: \" + uptime + \"\\n\");\n\n            var stat_writer = function(group, metric, val) {\n              var delta;\n\n              if (metric.match(\"^last_\")) {\n                delta = now - val;\n              }\n              else {\n                delta = val;\n              }\n\n              stream.write(group + \".\" + metric + \": \" + delta + \"\\n\");\n            };\n\n            // Loop through the base stats\n            for (var group in stats) {\n              for (var metric in stats[group]) {\n                stat_writer(group, metric, stats[group][metric]);\n              }\n            }\n\n            backendEvents.once('status', function(writeCb) {\n              stream.write(\"END\\n\\n\");\n            });\n\n            // Let each backend contribute its status\n            backendEvents.emit('status', function(err, name, stat, val) {\n              if (err) {\n                l.log(\"Failed to read stats for backend \" +\n                        name + \": \" + err);\n              } else {\n                stat_writer(name, stat, val);\n              }\n            });\n\n            break;\n\n          case \"counters\":\n            stream.write(util.inspect(counters) + \"\\n\");\n            stream.write(\"END\\n\\n\");\n            break;\n\n          case \"timers\":\n            stream.write(util.inspect(timers) + \"\\n\");\n            stream.write(\"END\\n\\n\");\n            break;\n\n          case \"gauges\":\n            stream.write(util.inspect(gauges) + \"\\n\");\n            stream.write(\"END\\n\\n\");\n            break;\n\n          case \"delcounters\":\n            mgmt.delete_stats(counters, parameters, stream);\n            break;\n\n          case \"deltimers\":\n            mgmt.delete_stats(timers, parameters, stream);\n            break;\n\n          case \"delgauges\":\n            mgmt.delete_stats(gauges, parameters, stream);\n            break;\n\n          case \"quit\":\n            stream.end();\n            break;\n\n          default:\n            stream.write(\"ERROR\\n\");\n            break;\n        }\n      },\n      function(err, stream) {\n        l.log('MGMT: Caught ' + err +', Moving on', 'WARNING');\n      }\n    );\n\n    serversLoaded = true;\n    util.log(\"server is up\", \"INFO\");\n\n    pctThreshold = config.percentThreshold || 90;\n    if (!Array.isArray(pctThreshold)) {\n      pctThreshold = [ pctThreshold ]; // listify percentiles so single values work the same\n    }\n\n    flushInterval = Number(config.flushInterval || 10000);\n    config.flushInterval = flushInterval;\n\n    if (config.backends) {\n      for (var j = 0; j < config.backends.length; j++) {\n        loadBackend(config, config.backends[j]);\n      }\n    } else {\n      // The default backend is graphite\n      loadBackend(config, './backends/graphite');\n    }\n\n    // Setup the flush timer\n    var flushInt = setTimeout(flushMetrics, getFlushTimeout(flushInterval));\n\n    if (keyFlushInterval > 0) {\n      var keyFlushPercent = Number((config.keyFlush && config.keyFlush.percent) || 100);\n      var keyFlushLog = config.keyFlush && config.keyFlush.log;\n\n      keyFlushInt = setInterval(function () {\n        var sortedKeys = [];\n\n        for (var key in keyCounter) {\n          sortedKeys.push([key, keyCounter[key]]);\n        }\n\n        sortedKeys.sort(function(a, b) { return b[1] - a[1]; });\n\n        var logMessage = \"\";\n        var timeString = (new Date()) + \"\";\n\n        // only show the top \"keyFlushPercent\" keys\n        for (var i = 0, e = sortedKeys.length * (keyFlushPercent / 100); i < e; i++) {\n          logMessage += timeString + \" count=\" + sortedKeys[i][1] + \" key=\" + sortedKeys[i][0] + \"\\n\";\n        }\n\n        if (keyFlushLog) {\n          var logFile = fs.createWriteStream(keyFlushLog, {flags: 'a+'});\n          logFile.write(logMessage);\n          logFile.end();\n        } else {\n          process.stdout.write(logMessage);\n        }\n\n        // clear the counter\n        keyCounter = {};\n      }, keyFlushInterval);\n    }\n  }\n});\n\nprocess.on('exit', function () {\n  flushMetrics();\n});\n"}